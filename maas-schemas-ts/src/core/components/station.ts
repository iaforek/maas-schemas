/*

undefined
MaaS station schemas

!!! AUTO GENERATED BY IOTSFJS REFRAIN FROM MANUAL EDITING !!!
See https://www.npmjs.com/package/io-ts-from-json-schema

*/

import * as t from 'io-ts';
import * as UnitsGeo_ from './units-geo';
import * as Address_ from './address';
import * as Common_ from './common';
import * as TravelMode_ from './travel-mode';
import * as Units_ from './units';

export const schemaId = 'http://maasglobal.com/core/components/station.json';

// Id
// The purpose of this remains a mystery
export type Id = t.Branded<string, IdBrand>;
export type IdC = t.BrandC<t.StringC, IdBrand>;
export const Id: IdC = t.brand(
  t.string,
  (x): x is t.Branded<string, IdBrand> =>
    (typeof x !== 'string' || x.length >= 1) && (typeof x !== 'string' || x.length <= 64),
  'Id',
);
export interface IdBrand {
  readonly Id: unique symbol;
}

// Code
// The purpose of this remains a mystery
export type Code = t.Branded<string, CodeBrand>;
export type CodeC = t.BrandC<t.StringC, CodeBrand>;
export const Code: CodeC = t.brand(
  t.string,
  (x): x is t.Branded<string, CodeBrand> => true,
  'Code',
);
export interface CodeBrand {
  readonly Code: unique symbol;
}

// Name
// The purpose of this remains a mystery
export type Name = t.Branded<string, NameBrand>;
export type NameC = t.BrandC<t.StringC, NameBrand>;
export const Name: NameC = t.brand(
  t.string,
  (x): x is t.Branded<string, NameBrand> => true,
  'Name',
);
export interface NameBrand {
  readonly Name: unique symbol;
}

// Location
// The purpose of this remains a mystery
export type Location = t.Branded<UnitsGeo_.ShortLocationString, LocationBrand>;
export type LocationC = t.BrandC<typeof UnitsGeo_.ShortLocationString, LocationBrand>;
export const Location: LocationC = t.brand(
  UnitsGeo_.ShortLocationString,
  (x): x is t.Branded<UnitsGeo_.ShortLocationString, LocationBrand> => true,
  'Location',
);
export interface LocationBrand {
  readonly Location: unique symbol;
}

// Address
// The purpose of this remains a mystery
export type Address = t.Branded<Address_.Address, AddressBrand>;
export type AddressC = t.BrandC<typeof Address_.Address, AddressBrand>;
export const Address: AddressC = t.brand(
  Address_.Address,
  (x): x is t.Branded<Address_.Address, AddressBrand> => true,
  'Address',
);
export interface AddressBrand {
  readonly Address: unique symbol;
}

// City
// The purpose of this remains a mystery
export type City = t.Branded<Address_.City, CityBrand>;
export type CityC = t.BrandC<typeof Address_.City, CityBrand>;
export const City: CityC = t.brand(
  Address_.City,
  (x): x is t.Branded<Address_.City, CityBrand> => true,
  'City',
);
export interface CityBrand {
  readonly City: unique symbol;
}

// Country
// The purpose of this remains a mystery
export type Country = t.Branded<Address_.Country, CountryBrand>;
export type CountryC = t.BrandC<typeof Address_.Country, CountryBrand>;
export const Country: CountryC = t.brand(
  Address_.Country,
  (x): x is t.Branded<Address_.Country, CountryBrand> => true,
  'Country',
);
export interface CountryBrand {
  readonly Country: unique symbol;
}

// AgencyId
// The purpose of this remains a mystery
export type AgencyId = t.Branded<Common_.AgencyId, AgencyIdBrand>;
export type AgencyIdC = t.BrandC<typeof Common_.AgencyId, AgencyIdBrand>;
export const AgencyId: AgencyIdC = t.brand(
  Common_.AgencyId,
  (x): x is t.Branded<Common_.AgencyId, AgencyIdBrand> => true,
  'AgencyId',
);
export interface AgencyIdBrand {
  readonly AgencyId: unique symbol;
}

// OpeningHours
// Opening hour of the station, object format is left for TSP to decide
export type OpeningHours = t.Branded<Record<string, unknown>, OpeningHoursBrand>;
export type OpeningHoursC = t.BrandC<t.UnknownRecordC, OpeningHoursBrand>;
export const OpeningHours: OpeningHoursC = t.brand(
  t.UnknownRecord,
  (x): x is t.Branded<Record<string, unknown>, OpeningHoursBrand> => true,
  'OpeningHours',
);
export interface OpeningHoursBrand {
  readonly OpeningHours: unique symbol;
}

// Facilities
// Station facilities, including services and features
export type Facilities = t.Branded<Array<string>, FacilitiesBrand>;
export type FacilitiesC = t.BrandC<t.ArrayC<t.StringC>, FacilitiesBrand>;
export const Facilities: FacilitiesC = t.brand(
  t.array(t.string),
  (x): x is t.Branded<Array<string>, FacilitiesBrand> => true,
  'Facilities',
);
export interface FacilitiesBrand {
  readonly Facilities: unique symbol;
}

// Services
// What agency and mode of transport will occupy this station
export type Services = t.Branded<Array<TravelMode_.TravelMode>, ServicesBrand>;
export type ServicesC = t.BrandC<t.ArrayC<typeof TravelMode_.TravelMode>, ServicesBrand>;
export const Services: ServicesC = t.brand(
  t.array(TravelMode_.TravelMode),
  (x): x is t.Branded<Array<TravelMode_.TravelMode>, ServicesBrand> => true,
  'Services',
);
export interface ServicesBrand {
  readonly Services: unique symbol;
}

// Timetables
// Timetable for passing by / originating transports
export type Timetables = t.Branded<
  Array<{
    id?: string;
    mode?: TravelMode_.TravelMode;
    name?: string;
    longName?: string;
    schedule?: Units_.Time;
    realtime?: Units_.Time;
    isRealtime?: boolean;
  }>,
  TimetablesBrand
>;
export type TimetablesC = t.BrandC<
  t.ArrayC<
    t.PartialC<{
      id: t.StringC;
      mode: typeof TravelMode_.TravelMode;
      name: t.StringC;
      longName: t.StringC;
      schedule: typeof Units_.Time;
      realtime: typeof Units_.Time;
      isRealtime: t.BooleanC;
    }>
  >,
  TimetablesBrand
>;
export const Timetables: TimetablesC = t.brand(
  t.array(
    t.partial({
      id: t.string,
      mode: TravelMode_.TravelMode,
      name: t.string,
      longName: t.string,
      schedule: Units_.Time,
      realtime: Units_.Time,
      isRealtime: t.boolean,
    }),
  ),
  (
    x,
  ): x is t.Branded<
    Array<{
      id?: string;
      mode?: TravelMode_.TravelMode;
      name?: string;
      longName?: string;
      schedule?: Units_.Time;
      realtime?: Units_.Time;
      isRealtime?: boolean;
    }>,
    TimetablesBrand
  > => true,
  'Timetables',
);
export interface TimetablesBrand {
  readonly Timetables: unique symbol;
}

// Zone
// Geofencing zone defined by provider that the station is within
export type Zone = t.Branded<number | string, ZoneBrand>;
export type ZoneC = t.BrandC<t.UnionC<[t.NumberC, t.StringC]>, ZoneBrand>;
export const Zone: ZoneC = t.brand(
  t.union([t.number, t.string]),
  (x): x is t.Branded<number | string, ZoneBrand> => true,
  'Zone',
);
export interface ZoneBrand {
  readonly Zone: unique symbol;
}

// PlatformCode
// Platform number
export type PlatformCode = t.Branded<number | string, PlatformCodeBrand>;
export type PlatformCodeC = t.BrandC<t.UnionC<[t.NumberC, t.StringC]>, PlatformCodeBrand>;
export const PlatformCode: PlatformCodeC = t.brand(
  t.union([t.number, t.string]),
  (x): x is t.Branded<number | string, PlatformCodeBrand> => true,
  'PlatformCode',
);
export interface PlatformCodeBrand {
  readonly PlatformCode: unique symbol;
}

// Station
// The default export. More information at the top.
export type Station = t.Branded<Record<string, unknown>, StationBrand>;
export type StationC = t.BrandC<t.UnknownRecordC, StationBrand>;
export const Station: StationC = t.brand(
  t.UnknownRecord,
  (x): x is t.Branded<Record<string, unknown>, StationBrand> => true,
  'Station',
);
export interface StationBrand {
  readonly Station: unique symbol;
}

export default Station;

// Success
