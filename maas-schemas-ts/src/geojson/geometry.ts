/*

GeoJSON Geometry
GeoJSON geometry, forked from https://github.com/fge/sample-json-schemas/ under BSD license

!!! AUTO GENERATED BY IOTSFJS REFRAIN FROM MANUAL EDITING !!!
See https://www.npmjs.com/package/io-ts-from-json-schema

*/

import * as t from 'io-ts';

export type Defined = {} | null;
export class DefinedType extends t.Type<Defined> {
  readonly _tag: 'DefinedType' = 'DefinedType';
  constructor() {
    super(
      'defined',
      (u): u is Defined => typeof u !== 'undefined',
      (u, c) => (this.is(u) ? t.success(u) : t.failure(u, c)),
      t.identity,
    );
  }
}
export interface DefinedC extends DefinedType {}
export const Defined: DefinedC = new DefinedType();

export const schemaId = 'http://maasglobal.com/geojson/geometry.json';

// Position
// A single position
export type Position = t.Branded<[number, number], PositionBrand>;
export type PositionC = t.BrandC<t.TupleC<[t.NumberC, t.NumberC]>, PositionBrand>;
export const Position: PositionC = t.brand(
  t.tuple([t.number, t.number]),
  (x): x is t.Branded<[number, number], PositionBrand> =>
    Array.isArray(x) === false || x.length >= 2,
  'Position',
);
export interface PositionBrand {
  readonly Position: unique symbol;
}

// PositionArray
// An array of positions
export type PositionArray = t.Branded<Array<Position>, PositionArrayBrand>;
export type PositionArrayC = t.BrandC<t.ArrayC<typeof Position>, PositionArrayBrand>;
export const PositionArray: PositionArrayC = t.brand(
  t.array(Position),
  (x): x is t.Branded<Array<Position>, PositionArrayBrand> => true,
  'PositionArray',
);
export interface PositionArrayBrand {
  readonly PositionArray: unique symbol;
}

// LineString
// An array of two or more positions
export type LineString = t.Branded<PositionArray & unknown, LineStringBrand>;
export type LineStringC = t.BrandC<
  t.IntersectionC<[typeof PositionArray, t.UnknownC]>,
  LineStringBrand
>;
export const LineString: LineStringC = t.brand(
  t.intersection([PositionArray, t.unknown]),
  (x): x is t.Branded<PositionArray & unknown, LineStringBrand> => true,
  'LineString',
);
export interface LineStringBrand {
  readonly LineString: unique symbol;
}

// LinearRing
// An array of four positions where the first equals the last
export type LinearRing = t.Branded<PositionArray & unknown, LinearRingBrand>;
export type LinearRingC = t.BrandC<
  t.IntersectionC<[typeof PositionArray, t.UnknownC]>,
  LinearRingBrand
>;
export const LinearRing: LinearRingC = t.brand(
  t.intersection([PositionArray, t.unknown]),
  (x): x is t.Branded<PositionArray & unknown, LinearRingBrand> => true,
  'LinearRing',
);
export interface LinearRingBrand {
  readonly LinearRing: unique symbol;
}

// Polygon
// An array of linear rings
export type Polygon = t.Branded<Array<LinearRing>, PolygonBrand>;
export type PolygonC = t.BrandC<t.ArrayC<typeof LinearRing>, PolygonBrand>;
export const Polygon: PolygonC = t.brand(
  t.array(LinearRing),
  (x): x is t.Branded<Array<LinearRing>, PolygonBrand> => true,
  'Polygon',
);
export interface PolygonBrand {
  readonly Polygon: unique symbol;
}

// Geometry
// The default export. More information at the top.
export type Geometry = t.Branded<
  Record<string, unknown> & {
    type: Defined;
    coordinates: Defined;
  } & (
      | {
          type?: 'Point';
          coordinates?: Position;
        }
      | {
          type?: 'MultiPoint';
          coordinates?: PositionArray;
        }
      | {
          type?: 'LineString';
          coordinates?: LineString;
        }
      | {
          type?: 'MultiLineString';
          coordinates?: Array<LineString>;
        }
      | {
          type?: 'Polygon';
          coordinates?: Polygon;
        }
      | {
          type?: 'MultiPolygon';
          coordinates?: Array<Polygon>;
        }
    ),
  GeometryBrand
>;
export type GeometryC = t.BrandC<
  t.IntersectionC<
    [
      t.UnknownRecordC,
      t.TypeC<{
        type: typeof Defined;
        coordinates: typeof Defined;
      }>,
      t.UnionC<
        [
          t.PartialC<{
            type: t.LiteralC<'Point'>;
            coordinates: typeof Position;
          }>,
          t.PartialC<{
            type: t.LiteralC<'MultiPoint'>;
            coordinates: typeof PositionArray;
          }>,
          t.PartialC<{
            type: t.LiteralC<'LineString'>;
            coordinates: typeof LineString;
          }>,
          t.PartialC<{
            type: t.LiteralC<'MultiLineString'>;
            coordinates: t.ArrayC<typeof LineString>;
          }>,
          t.PartialC<{
            type: t.LiteralC<'Polygon'>;
            coordinates: typeof Polygon;
          }>,
          t.PartialC<{
            type: t.LiteralC<'MultiPolygon'>;
            coordinates: t.ArrayC<typeof Polygon>;
          }>,
        ]
      >,
    ]
  >,
  GeometryBrand
>;
export const Geometry: GeometryC = t.brand(
  t.intersection([
    t.UnknownRecord,
    t.type({
      type: Defined,
      coordinates: Defined,
    }),
    t.union([
      t.partial({
        type: t.literal('Point'),
        coordinates: Position,
      }),
      t.partial({
        type: t.literal('MultiPoint'),
        coordinates: PositionArray,
      }),
      t.partial({
        type: t.literal('LineString'),
        coordinates: LineString,
      }),
      t.partial({
        type: t.literal('MultiLineString'),
        coordinates: t.array(LineString),
      }),
      t.partial({
        type: t.literal('Polygon'),
        coordinates: Polygon,
      }),
      t.partial({
        type: t.literal('MultiPolygon'),
        coordinates: t.array(Polygon),
      }),
    ]),
  ]),
  (
    x,
  ): x is t.Branded<
    Record<string, unknown> & {
      type: Defined;
      coordinates: Defined;
    } & (
        | {
            type?: 'Point';
            coordinates?: Position;
          }
        | {
            type?: 'MultiPoint';
            coordinates?: PositionArray;
          }
        | {
            type?: 'LineString';
            coordinates?: LineString;
          }
        | {
            type?: 'MultiLineString';
            coordinates?: Array<LineString>;
          }
        | {
            type?: 'Polygon';
            coordinates?: Polygon;
          }
        | {
            type?: 'MultiPolygon';
            coordinates?: Array<Polygon>;
          }
      ),
    GeometryBrand
  > => true,
  'Geometry',
);
export interface GeometryBrand {
  readonly Geometry: unique symbol;
}

export default Geometry;

// Success
